{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"@babel/runtime/regenerator\");\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar memoryStore = {};\nexports.default = {\n  setItem: function setItem(key, value) {\n    return _regeneratorRuntime.async(function setItem$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            memoryStore[key] = value;\n\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  getAllKeys: function getAllKeys() {\n    return _regeneratorRuntime.async(function getAllKeys$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            return _context2.abrupt(\"return\", Object.keys(memoryStore));\n\n          case 1:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  getItem: function getItem(key) {\n    return _regeneratorRuntime.async(function getItem$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            return _context3.abrupt(\"return\", memoryStore[key]);\n\n          case 1:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  multiGet: function multiGet(keys) {\n    var results, _iterator, _step, key;\n\n    return _regeneratorRuntime.async(function multiGet$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            results = [];\n\n            for (_iterator = _createForOfIteratorHelperLoose(keys); !(_step = _iterator()).done;) {\n              key = _step.value;\n              results.push([key, memoryStore[key]]);\n            }\n\n            return _context4.abrupt(\"return\", results);\n\n          case 3:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  multiRemove: function multiRemove(keys) {\n    var _iterator2, _step2, key;\n\n    return _regeneratorRuntime.async(function multiRemove$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            for (_iterator2 = _createForOfIteratorHelperLoose(keys); !(_step2 = _iterator2()).done;) {\n              key = _step2.value;\n              delete memoryStore[key];\n            }\n\n          case 1:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  removeItem: function removeItem(key) {\n    return _regeneratorRuntime.async(function removeItem$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            delete memoryStore[key];\n\n          case 1:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  }\n};","map":{"version":3,"sources":["../src/memoryStore.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAAA,IAAM,WAAW,GAAQ,EAAzB;AAEA,OAAA,CAAA,OAAA,GAAe;AACX,EAAA,OAAO,EAAE,iBAAO,GAAP,EAAoB,KAApB;AAAA;AAAA;AAAA;AAAA;AACL,YAAA,WAAW,CAAC,GAAD,CAAX,GAAmB,KAAnB;;AADK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GADE;AAKX,EAAA,UAAU,EAAE;AAAA;AAAA;AAAA;AAAA;AAAA,8CACD,MAAM,CAAC,IAAP,CAAY,WAAZ,CADC;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GALD;AASX,EAAA,OAAO,EAAE,iBAAO,GAAP;AAAA;AAAA;AAAA;AAAA;AAAA,8CACE,WAAW,CAAC,GAAD,CADb;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GATE;AAaX,EAAA,QAAQ,EAAE,kBAAO,IAAP;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA,YAAA,OADA,GACmB,EADnB;;AAEN,6DAAkB,IAAlB,iCAAwB;AAAb,cAAA,GAAa;AACpB,cAAA,OAAO,CAAC,IAAR,CAAa,CAAC,GAAD,EAAM,WAAW,CAAC,GAAD,CAAjB,CAAb;AACH;;AAJK,8CAMC,OAND;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAbC;AAsBX,EAAA,WAAW,EAAE,qBAAO,IAAP;AAAA;;AAAA;AAAA;AAAA;AAAA;AACT,8DAAkB,IAAlB,mCAAwB;AAAb,cAAA,GAAa;AACpB,qBAAO,WAAW,CAAC,GAAD,CAAlB;AACH;;AAHQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAtBF;AA4BX,EAAA,UAAU,EAAE,oBAAO,GAAP;AAAA;AAAA;AAAA;AAAA;AACR,mBAAO,WAAW,CAAC,GAAD,CAAlB;;AADQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA5BD,CAAf","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst memoryStore = {};\nexports.default = {\n    setItem: async (key, value) => {\n        memoryStore[key] = value;\n    },\n    getAllKeys: async () => {\n        return Object.keys(memoryStore);\n    },\n    getItem: async (key) => {\n        return memoryStore[key];\n    },\n    multiGet: async (keys) => {\n        const results = [];\n        for (const key of keys) {\n            results.push([key, memoryStore[key]]);\n        }\n        return results;\n    },\n    multiRemove: async (keys) => {\n        for (const key of keys) {\n            delete memoryStore[key];\n        }\n    },\n    removeItem: async (key) => {\n        delete memoryStore[key];\n    }\n};\n//# sourceMappingURL=memoryStore.js.map"]},"metadata":{},"sourceType":"script"}